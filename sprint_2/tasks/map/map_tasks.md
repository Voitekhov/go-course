
# 10 задач на ассоциативный массив в Go

## 1. Подсчёт количества вхождений слов

**Название:** Подсчитать количество повторений слов в списке

**Описание:**  
Дан срез строк `[]string` — список слов. Нужно посчитать, сколько раз каждое слово встречается, и сохранить результат в `map[string]int`, где ключ — слово, значение — количество вхождений.

**Ожидаемые входные данные:**  
Срез строк, например:
```go
[]string{"go", "java", "go", "python", "go", "java"}
```

**Ожидаемые выходные данные:**  
Карта вида:
```go
map[string]int{
    "go":     3,
    "java":   2,
    "python": 1,
}
```

---

## 2. Проверка наличия пользователя в системе

**Название:** Проверить, зарегистрирован ли пользователь

**Описание:**  
Есть `map[string]bool`, где ключ — логин пользователя, значение — флаг, активен он или нет. Нужно написать функцию, которая по логину пользователя возвращает:
- `true`, если пользователь есть в карте (неважно, активен он или нет),
- `false`, если пользователя нет вообще.

**Ожидаемые входные данные:**  
Карта:
```go
map[string]bool{
    "alice": true,
    "bob":   false,
}
```
И строка логина, например: `"alice"` или `"charlie"`.

**Ожидаемые выходные данные:**
- Для `"alice"` → `true`
- Для `"charlie"` → `false`

---

## 3. Фильтрация карт по значению

**Название:** Оставить только элементы больше порога

**Описание:**  
Дана карта `map[string]int`, где ключ — имя товара, значение — его количество на складе. Написать функцию, которая принимает карту и порог `min` и возвращает новую карту, в которой остаются только те товары, количество которых строго больше `min`.

**Ожидаемые входные данные:**  
Карта:
```go
map[string]int{
    "apple":  5,
    "banana": 1,
    "orange": 10,
}
```

Порог:
```go
min := 3
```

**Ожидаемые выходные данные:**  
Новая карта:
```go
map[string]int{
    "apple":  5,
    "orange": 10,
}
```

---

## 4. Разворот карты (swap key/value)

**Название:** Поменять местами ключи и значения

**Описание:**  
Дана карта `map[string]int`, где ключ — код пользователя, значение — его ID. Нужно построить новую карту `map[int]string`, где ключ — ID, значение — код пользователя. Можно считать, что все ID уникальны.

**Ожидаемые входные данные:**  
Карта:
```go
map[string]int{
    "user1": 10,
    "user2": 20,
    "user3": 30,
}
```

**Ожидаемые выходные данные:**  
Карта:
```go
map[int]string{
    10: "user1",
    20: "user2",
    30: "user3",
}
```

---

## 5. Группировка строк по длине

**Название:** Сгруппировать строки по длине

**Описание:**  
Дан срез строк `[]string`. Нужно вернуть карту `map[int][]string`, где ключ — длина строки, значение — срез всех строк такой длины.

**Ожидаемые входные данные:**  
Срез:
```go
[]string{"go", "java", "rust", "c", "js"}
```

**Ожидаемые выходные данные:**  
Карта:
```go
map[int][]string{
    1: {"c"},
    2: {"go", "js"},
    4: {"java", "rust"},
}
```

(Порядок в срезах может отличаться.)

---

## 6. Объединение двух карт с суммированием значений

**Название:** Объединить карты с суммой значений

**Описание:**  
Есть две карты `map[string]int`, в которых хранятся, например, продажи товаров по разным магазинам. Нужно объединить их в одну карту. Если ключ встречается в обеих картах — сложить значения, если только в одной — просто перенести значение.

**Ожидаемые входные данные:**
```go
a := map[string]int{
    "apple":  5,
    "banana": 2,
}

b := map[string]int{
    "banana": 3,
    "orange": 4,
}
```

**Ожидаемые выходные данные:**
```go
map[string]int{
    "apple":  5,
    "banana": 5, // 2 + 3
    "orange": 4,
}
```

---

## 7. Инверсия булевой карты

**Название:** Инвертировать значения флагов

**Описание:**  
Есть карта `map[string]bool`, которая хранит флаги, включена ли какая-то настройка. Нужно вернуть новую карту, где все значения будут инвертированы (`true` → `false`, `false` → `true`).

**Ожидаемые входные данные:**
```go
map[string]bool{
    "featureA": true,
    "featureB": false,
    "featureC": true,
}
```

**Ожидаемые выходные данные:**
```go
map[string]bool{
    "featureA": false,
    "featureB": true,
    "featureC": false,
}
```

---

## 8. Удаление элементов по условию

**Название:** Удалить элементы меньше заданного значения

**Описание:**  
Есть карта `map[int]int`, где ключ — ID, значение — рейтинг. Нужно удалить из карты все элементы, у которых рейтинг меньше заданного порога `limit`. Удаление должно происходить в исходной карте (in-place).

**Ожидаемые входные данные:**
```go
ratings := map[int]int{
    1: 10,
    2: 3,
    3: 7,
    4: 1,
}
limit := 5
```

**Ожидаемые выходные данные:**  
Исходная карта после вызова функции:
```go
map[int]int{
    1: 10,
    3: 7,
}
```

---

## 9. Подсчёт уникальных элементов

**Название:** Посчитать количество уникальных элементов в срезе

**Описание:**  
Дан срез целых чисел `[]int`. Нужно посчитать, сколько в нём уникальных значений, используя `map[int]bool` или `map[int]struct{}`.

**Ожидаемые входные данные:**
```go
[]int{1, 2, 2, 3, 4, 4, 4, 5}
```

**Ожидаемые выходные данные:**  
Число:
```go
5
```

(Уникальные элементы: 1, 2, 3, 4, 5.)

---

## 10. Частотный словарь букв

**Название:** Построить частотный словарь букв в строке

**Описание:**  
Дана строка (например, одно слово или короткая фраза). Нужно посчитать, сколько раз каждая буква встречается в строке, и сохранить результат в `map[rune]int`. Пробелы можно игнорировать или считать отдельно — на твой выбор, но это должно быть описано в комментарии к решению.

**Ожидаемые входные данные:**  
Строка:
```go
"hello world"
```

**Ожидаемые выходные данные:**  
Карта вида (пример):
```go
map[rune]int{
    'h': 1,
    'e': 1,
    'l': 3,
    'o': 2,
    'w': 1,
    'r': 1,
    'd': 1,
    // пробел можно не учитывать
}
```

---
# 5 задач на множества (set) в Go 

## 1. Пересечение множеств

**Название:** Найти пересечение двух множеств  
**Описание:**  
Даны два множества `map[int]bool{}`. Нужно создать новое множество, содержащее только те элементы, которые присутствуют одновременно в обоих множествах.

**Ожидаемые входные данные:**
```go
A = map[int]bool{1:true, 2:true, 3:true, 5:true}
B = map[int]bool{3:true, 4:true, 5:true, 6:true}
```

**Ожидаемые выходные данные:**
```go
map[int]bool{3:true, 5:true}
```

---

## 2. Разность множеств

**Название:** Найти элементы, которые входят в A, но отсутствуют в B  
**Описание:**  
Даны множества `A` и `B`. Нужно вернуть новое множество, содержащее элементы, которые есть в A, но которых нет в B (difference).

**Ожидаемые входные данные:**
```go
A = map[int]bool{10:true, 20:true, 30:true, 40:true}
B = map[int]bool{20:true, 40:true}
```

**Ожидаемые выходные данные:**
```go
map[int]bool{10:true, 30:true}
```

---

## 3. Объединение множеств

**Название:** Объединить два множества  
**Описание:**  
Даны множества строк `A` и `B` в виде `map[string]bool{}`. Нужно создать новое множество, содержащее все уникальные элементы из обоих множеств.

**Ожидаемые входные данные:**
```go
A = map[string]bool{"go":true, "java":true, "rust":true}
B = map[string]bool{"rust":true, "python":true}
```

**Ожидаемые выходные данные:**
```go
map[string]bool{"go":true, "java":true, "rust":true, "python":true}
```

---

## 4. Проверка на подмножество

**Название:** Проверить, является ли A подмножеством B  
**Описание:**  
Нужно определить, содержит ли множество `B` все элементы множества `A`.

**Ожидаемые входные данные:**
```go
A = map[int]bool{1:true, 2:true}
B = map[int]bool{1:true, 2:true, 3:true, 4:true}
```

**Ожидаемые выходные данные:**
```
true
```

---

## 5. Симметрическая разность

**Название:** Найти элементы, которые входят только в одно из множеств  
**Описание:**  
Симметрическая разность — элементы, которые есть в A или B, но не в обоих сразу.

**Ожидаемые входные данные:**
```go
A = map[int]bool{1:true, 2:true, 3:true}
B = map[int]bool{3:true, 4:true, 5:true}
```

**Ожидаемые выходные данные:**
```go
map[int]bool{1:true, 2:true, 4:true, 5:true}
```

---

